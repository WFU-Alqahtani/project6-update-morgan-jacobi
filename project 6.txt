The complexity for InsertionSort is either O(n) in a best-case scenario or O(n^2) in a worst-case scenario. InsertionSort must scan the entire list, compare the list, and then swap the elements if they are found to be out of order. So, if the list is already in sorted order, the complexity will be O(n) since it does not need to perform any swaps. On the other hand, if the list is out of order, InsertionSort must perform the steps stated above. This would cause InsertionSort to have a complexity of O(n^2). Therefore, is the list is, for the most part, in order, InsertionSort would be good to use; however, if it is not, then something like MergeSort (which we covered in project 3) would be better to use. 


The complexity of insertion data to a linked list is O(n) since we need to find the node in which we want to insert the item. However, if we were to insert data to the head or to the tail of the nodes, the complexity would be O(1) since we already have a pointer to these places and do not have to search through the entire list.